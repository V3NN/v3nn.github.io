<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>V3NN</title>
        <link>http://example.org/</link>
        <description>V3NN</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Mon, 01 Jul 2024 00:00:00 &#43;0000</lastBuildDate>
            <atom:link href="http://example.org/index.xml" rel="self" type="application/rss+xml" />
        <item>
    <title>RabbitMQ 系列1</title>
    <link>http://example.org/posts/rabbitmq/one/</link>
    <pubDate>Mon, 01 Jul 2024 00:00:00 &#43;0000</pubDate>
    <author>v3nn</author>
    <guid>http://example.org/posts/rabbitmq/one/</guid>
    <description><![CDATA[1 概述 RabbitMQ 是由 erlang 语言开发，基于AMQP（Advanced Message Queue 高级消息队列协议）协议实现的消息队列，它是一种应用程序之间的通信方法，消息队列在分布式系统开发中应用非常广泛。
2 基本概念 2.1 基本结构 Producer 消息生产者，即生产方客户端，生产方客户端将消息发送。
Connection 生产者和消费者，需要与 Broker 建立连接，也就是 Connection, 一旦连接建立起来，客户端会创建一个AMQP 信道，也就是 channel。信道是建立在Connection 之上的虚拟连接，Broken处理的每条AMQP 指定都是通过信道channel完成的。
Broker 消息队列服务进程，此进程包括两个部分：Exchange 和 Queue
Exchange
消息队列交换机，按一定的规则将消息路由转发到某个队列，对消息进行过虑。 交换机支持多种类型，每种类型都用于不同的消息路由和分发策略。
Direct Exchange： 这种交换机根据消息的路由键（Routing Key）将消息发送到与之完全匹配的队列。只有当消息的路由键与队列绑定时指定的路由键完全相同时，消息才会被路由到队列。这是一种简单的路由策略，适用于点对点通信。
Topic Exchange：这种交换机根据消息的路由键与队列绑定时指定的路由键模式（通配符）匹配程度，将消息路由到一个或多个队列。路由键可以使用通配符符号 *（匹配一个单词）和 #（匹配零个或多个单词），允许更灵活的消息路由。用于发布/订阅模式和复杂的消息路由需求。
Headers Exchange：这种交换机根据消息的标头信息（Headers）来决定消息的路由，而不是使用路由键。队列和交换机之间的绑定规则是根据标头键值对来定义的，只有当消息的标头与绑定规则完全匹配时，消息才会被路由到队列。适用于需要复杂消息匹配的场景。
Fanout Exchange：这种交换机将消息广播到与之绑定的所有队列，无论消息的路由键是什么。
Default Exchange：这是默认实现的一种交换机，它不需要手动创建。当消息发布到默认交换机时，路由键会被解释为队列的名称，消息会被路由到与路由键名称相同的队列。默认交换机通常用于点对点通信，但不支持复杂的路由策略。
Queue
消息队列，存储消息的队列，消息到达队列并转发给指定的消费者。
Consumer 消息消费者，即消费方客户端，接收 Broker 转发的消息。
2.2 工作流程 如上图所示，蓝色的圈圈就是我们的消息推送服务，将消息推送到中间方框里面也就是 RabbitMQ的服务器，然后经过服务器里面的Exchange、queue等各种关系将数据处理入列后，最终右边的绿色圈圈消费者获取对应监听的消息。
生产者：
1、生产者和Broker建立TCP连接。 2、生产者和Broker建立通道。 3、生产者通过通道消息发送给Broker，由Exchange将消息进行转发。 4、Exchange将消息转发到指定的Queue
消费者：
1、消费者和 Broker 建立 TCP 连接 2、消费者和 Broker 建立通道 3、消费者监听指定的Queue 4、当有消息到达 Queue 时 Broker 默认将消息推送给消费者。 5、消费者接收到消息。 6、ack回复]]></description>
</item>
<item>
    <title>一文了解MySQL JSON相关函数</title>
    <link>http://example.org/posts/mysql/json-function-reference/</link>
    <pubDate>Fri, 01 Dec 2023 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>http://example.org/posts/mysql/json-function-reference/</guid>
    <description><![CDATA[1. 介绍 JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式，目前常用于前后段数据传输。
MySQL 从 5.7.8 版本开始提供 JSON 数据类型及相关函数，其通过新增JSON对象类型和相应的函数来解析和生成 JSON格式数据，使得 MySQL 在处理 JSON数据方面更加高效便捷，以下介绍常用相关函数。
2. 创建JSON JSON_ARRAY JSON_ARRAY([val[, val] ...])
接受一个值列表(可能为NULL)，并返回一个包含这些值的 JSON 数组
mysql&gt; SELECT JSON_ARRAY(1, &#34;abc&#34;, NULL, TRUE, CURTIME()); +---------------------------------------------+ | JSON_ARRAY(1, &#34;abc&#34;, NULL, TRUE, CURTIME()) | +---------------------------------------------+ | [1, &#34;abc&#34;, null, true, &#34;11:30:24.000000&#34;] | +---------------------------------------------+ JSON_OBJECT JSON_OBJECT([key, val[, key, val] ...])
接受一个键值对(可以为NULL)列表，并返回一个包含这些键值对的 JSON 对象
mysql&gt; SELECT JSON_OBJECT(&#39;id&#39;, 87, &#39;name&#39;, &#39;carrot&#39;, &#39;addr&#39;, null); +--------------------------------------------------------------+ | SELECT JSON_OBJECT(&#39;id&#39;, 87, &#39;name&#39;, &#39;carrot&#39;, &#39;addr&#39;, null) | +--------------------------------------------------------------+ | {&#34;id&#34;: 87, &#34;addr&#34;: null, &#34;name&#34;: &#34;carrot&#34;} | +--------------------------------------------------------------+ 3.]]></description>
</item>
<item>
    <title>Redis的过期策略及内存淘汰机制</title>
    <link>http://example.org/posts/redis/taotaijizhi/</link>
    <pubDate>Tue, 11 Jul 2023 00:00:00 &#43;0000</pubDate>
    <author>v3nn</author>
    <guid>http://example.org/posts/redis/taotaijizhi/</guid>
    <description><![CDATA[Redis 作为当前最常用的开源内存数据库，性能十分高。但是长期将Redis作为缓存使用，难免会遇到内存空间存储瓶颈，当Redis内存超出物理内存限制时，内存数据就会与磁盘产生频繁交换，使Redis性能急剧下降。此时如何淘汰无用数据释放空间、存储新数据就变得尤为重要了。
Redis 提供了两种机制配合来达到上述目的：过期策略和内存淘汰机制。
过期策略 redis的key已经设置了TTL，不是过期就已经删除了吗？为什么还存在所谓的淘汰策略呢？这个原因我们需要从redis的过期策略聊起。
定期删除 定期删除类似一个守护线程，每间隔一段时间就执行一次，将过期的Key进行删除，具体过程如下：
从过期字典中随机选出20个key 删除这20个key中已经过期的key 如果过期的key的比例超过了1/4，那就重复从步骤1开始执行 redis默认是每隔 100ms就随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除。
注意这里是随机抽取的。
为什么要随机呢？假如 redis 存了几十万个 key ，每隔100ms就遍历所有的设置过期时间的 key 的话，就会给 CPU 带来很大的负载。
这样随机的抽取明显会遗漏很多过期key，这就要用到惰性删除。
惰性删除 定期删除可能会导致很多过期 key 到了时间并没有被删除掉。所以就有了惰性删除。
假如你的过期 key，靠定期删除没有被删除掉，还停留在内存里，除非你的系统去查一下那个 key，才会被redis给删除掉。这就是所谓的惰性删除。
定期删除是集中处理，惰性删除是零散处理。
内存淘汰策略 有了以上过期策略的说明后，就很容易理解为什么需要淘汰策略了，因为不管是定期删除还是惰性删除都不是一种完全精准的删除，就还是会存在key没有被删除掉的场景，所以就需要内存淘汰策略进行补充。
淘汰策略 目前redis提供了以下几种（2个LFU的策略是4.0后出现的）：
noeviction (默认策略)，不会淘汰任何数据，当使用的内存空间超过 maxmemory 值时，再有写请求来时返回错误。
allkeys-lru，添加键的时候如果过限，首先驱逐最久没有使用的键。
volatile-lru，添加键的时候如果过限，首先从设置了过期时间的键集合中驱逐最久没有使用的键。
allkeys-lfu，从所有键中驱逐使用频率最少的键。
volatile-lfu，从所有配置了过期时间的键中驱逐使用频率最少的键。
allkeys-random，添加键的时候如果过限，从所有key随机删除。
volatile-random，加入键的时候如果过限，从过期键的集合中随机驱逐。
volatile-ttl，从配置了过期时间的键中驱逐马上就要过期的键。
当使用volatile-lru、volatile-random、volatile-ttl这三种策略时，如果没有key可以被淘汰，则和noeviction一样返回错误。
除了比较特殊的noeviction与volatile-ttl，其余6种策略都有一定的关联性，可以通过前缀将它们分为2类，volatile-与volatile-ttl。
volatile- 前缀的策略代表从设置了过期时间的key中选择键进行清除；
allkeys-开头的策略代表从所有key中选择键进行清除。
这里面值得介绍的就是LRU与LFU算法。
LRU LRU是Least Recently Used的缩写，也就是表示最近很少使用，也可以理解成最久没有使用。也就是说当内存不够的时候，每次添加一条数据，都需要抛弃一条最久时间没有使用的旧数据。
需要注意的是redis并没有使用标准的LRU实现方法作为LRU淘汰策略的实现方式，这是因为：
要实现LRU，需要将所有数据维护一个链表，这就需额外内存空间来保存链表
每当有新数据插入或现有数据被再次访问，都要调整链表中节点的位置，尤其是频繁的操作将会造成巨大的开销
为了解决这一问题，redis使用了近似的LRU策略进行了优化：
首先定义一个淘汰池，这个淘汰池是一个数组（大小为16），然后触发淘汰时会根据配置的淘汰策略，先从符合条件的key中随机采样选出5（可在配置文件中配置）个key，然后将这5个key按照空闲时间排序后放到淘汰池中，每次采样之后更新这个淘汰池，让这个淘汰池里保留的总是那些随机采样出的key中空闲时间最长的那部分key。需要删除key时，只需将淘汰池中空闲时间最长的key删掉即可。
LFU LRU的最近最少使用实际上并不精确，考虑下面的情况:
A~ ~A~ ~A~ ~A~ ~A~ ~A~ ~A~ ~A~ ~A~ ~A~ ~ ~ ~|B~ ~ ~ ~ ~B~ ~ ~ ~ ~B~ ~ ~ ~ ~B~ ~ ~ ~ ~ ~~B| 如果在|处删除，那么A距离的时间最久，但实际上A的使用频率要比B频繁，所以合理的淘汰策略应该是淘汰B。]]></description>
</item>
<item>
    <title>Markdown 基本语法 1</title>
    <link>http://example.org/posts/my-first-post/</link>
    <pubDate>Sun, 01 Dec 2019 21:57:40 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://example.org/posts/my-first-post/</guid>
    <description><![CDATA[这篇文章提供了可以在 Hugo 的文章中使用的基本 Markdown 语法示例.
Note 这篇文章借鉴了一篇很棒的来自 Grav 的文章 .
如果你想了解 Loveit 主题的扩展 Markdown 语法, 请阅读扩展 Markdown 语法页面 .
事实上, 编写 Web 内容很麻烦. <strong><ruby>WYSIWYG<rt>所见即所得</rt></ruby></strong> 编辑器帮助减轻了这一任务. 但通常会导致代码太糟, 或更糟糕的是, 网页也会很丑.
没有通常伴随的所有复杂和丑陋的问题, Markdown 是一种更好的生成 HTML 内容的方式.
一些主要好处是:
Markdown 简单易学, 几乎没有多余的字符, 因此编写内容也更快. 用 Markdown 书写时出错的机会更少. 可以产生有效的 XHTML 输出. 将内容和视觉显示保持分开, 这样就不会打乱网站的外观. 可以在你喜欢的任何文本编辑器或 Markdown 应用程序中编写内容. Markdown 使用起来很有趣! John Gruber, Markdown 的作者如是说:
The Stormtroopocat The Stormtroopocat 1 标题 从 h2 到 h6 的标题在每个级别上都加上一个 ＃:
## h2 标题 ### h3 标题 #### h4 标题 ##### h5 标题 ###### h6 标题 2 注释 注释是和 HTML 兼容的：]]></description>
</item>
</channel>
</rss>
