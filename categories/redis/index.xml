<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Redis - Category - V3NN</title>
        <link>http://example.org/categories/redis/</link>
        <description>Redis - Category - V3NN</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Tue, 11 Jul 2023 00:00:00 &#43;0000</lastBuildDate><atom:link href="http://example.org/categories/redis/" rel="self" type="application/rss+xml" /><item>
    <title>Redis的过期策略及内存淘汰机制</title>
    <link>http://example.org/posts/redis/taotaijizhi/</link>
    <pubDate>Tue, 11 Jul 2023 00:00:00 &#43;0000</pubDate>
    <author>v3nn</author>
    <guid>http://example.org/posts/redis/taotaijizhi/</guid>
    <description><![CDATA[Redis 作为当前最常用的开源内存数据库，性能十分高。但是长期将Redis作为缓存使用，难免会遇到内存空间存储瓶颈，当Redis内存超出物理内存限制时，内存数据就会与磁盘产生频繁交换，使Redis性能急剧下降。此时如何淘汰无用数据释放空间、存储新数据就变得尤为重要了。
Redis 提供了两种机制配合来达到上述目的：过期策略和内存淘汰机制。
过期策略 redis的key已经设置了TTL，不是过期就已经删除了吗？为什么还存在所谓的淘汰策略呢？这个原因我们需要从redis的过期策略聊起。
定期删除 定期删除类似一个守护线程，每间隔一段时间就执行一次，将过期的Key进行删除，具体过程如下：
从过期字典中随机选出20个key 删除这20个key中已经过期的key 如果过期的key的比例超过了1/4，那就重复从步骤1开始执行 redis默认是每隔 100ms就随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除。
注意这里是随机抽取的。
为什么要随机呢？假如 redis 存了几十万个 key ，每隔100ms就遍历所有的设置过期时间的 key 的话，就会给 CPU 带来很大的负载。
这样随机的抽取明显会遗漏很多过期key，这就要用到惰性删除。
惰性删除 定期删除可能会导致很多过期 key 到了时间并没有被删除掉。所以就有了惰性删除。
假如你的过期 key，靠定期删除没有被删除掉，还停留在内存里，除非你的系统去查一下那个 key，才会被redis给删除掉。这就是所谓的惰性删除。
定期删除是集中处理，惰性删除是零散处理。
内存淘汰策略 有了以上过期策略的说明后，就很容易理解为什么需要淘汰策略了，因为不管是定期删除还是惰性删除都不是一种完全精准的删除，就还是会存在key没有被删除掉的场景，所以就需要内存淘汰策略进行补充。
淘汰策略 目前redis提供了以下几种（2个LFU的策略是4.0后出现的）：
noeviction (默认策略)，不会淘汰任何数据，当使用的内存空间超过 maxmemory 值时，再有写请求来时返回错误。
allkeys-lru，添加键的时候如果过限，首先驱逐最久没有使用的键。
volatile-lru，添加键的时候如果过限，首先从设置了过期时间的键集合中驱逐最久没有使用的键。
allkeys-lfu，从所有键中驱逐使用频率最少的键。
volatile-lfu，从所有配置了过期时间的键中驱逐使用频率最少的键。
allkeys-random，添加键的时候如果过限，从所有key随机删除。
volatile-random，加入键的时候如果过限，从过期键的集合中随机驱逐。
volatile-ttl，从配置了过期时间的键中驱逐马上就要过期的键。
当使用volatile-lru、volatile-random、volatile-ttl这三种策略时，如果没有key可以被淘汰，则和noeviction一样返回错误。
除了比较特殊的noeviction与volatile-ttl，其余6种策略都有一定的关联性，可以通过前缀将它们分为2类，volatile-与volatile-ttl。
volatile- 前缀的策略代表从设置了过期时间的key中选择键进行清除；
allkeys-开头的策略代表从所有key中选择键进行清除。
这里面值得介绍的就是LRU与LFU算法。
LRU LRU是Least Recently Used的缩写，也就是表示最近很少使用，也可以理解成最久没有使用。也就是说当内存不够的时候，每次添加一条数据，都需要抛弃一条最久时间没有使用的旧数据。
需要注意的是redis并没有使用标准的LRU实现方法作为LRU淘汰策略的实现方式，这是因为：
要实现LRU，需要将所有数据维护一个链表，这就需额外内存空间来保存链表
每当有新数据插入或现有数据被再次访问，都要调整链表中节点的位置，尤其是频繁的操作将会造成巨大的开销
为了解决这一问题，redis使用了近似的LRU策略进行了优化：
首先定义一个淘汰池，这个淘汰池是一个数组（大小为16），然后触发淘汰时会根据配置的淘汰策略，先从符合条件的key中随机采样选出5（可在配置文件中配置）个key，然后将这5个key按照空闲时间排序后放到淘汰池中，每次采样之后更新这个淘汰池，让这个淘汰池里保留的总是那些随机采样出的key中空闲时间最长的那部分key。需要删除key时，只需将淘汰池中空闲时间最长的key删掉即可。
LFU LRU的最近最少使用实际上并不精确，考虑下面的情况:
A~ ~A~ ~A~ ~A~ ~A~ ~A~ ~A~ ~A~ ~A~ ~A~ ~ ~ ~|B~ ~ ~ ~ ~B~ ~ ~ ~ ~B~ ~ ~ ~ ~B~ ~ ~ ~ ~ ~~B| 如果在|处删除，那么A距离的时间最久，但实际上A的使用频率要比B频繁，所以合理的淘汰策略应该是淘汰B。]]></description>
</item>
</channel>
</rss>
